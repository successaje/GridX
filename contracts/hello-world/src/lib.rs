#![no_std]
use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, String, Address, Map, Vec, BytesN};
// use crate::__energytrading_fn_set_registry::std::string::ToString;

mod gdxtoken {
    soroban_sdk::contractimport!(
            file = "/Users/finisher/Documents/github/gdx-token/target/wasm32-unknown-unknown/release/gdx_token_contract.wasm"
    );
}

#[contract]
pub struct EnergyTrading;

#[contractimpl]
impl EnergyTrading {

    // Register users with roles: Generator, Consumer, Admin
    pub fn register_user(env: Env, user: Address, role: String) {
        let roles_key = symbol_short!("roles");
        env.storage().persistent().set(&(roles_key.clone(), &user), &role);
        env.events().publish(("register", user.clone()), role);
    }

    pub fn get_user_role(env: Env, user: Address) -> String {
        let roles_key = symbol_short!("roles");
        env.storage().persistent().get(&(roles_key, &user))
            .unwrap_or_else(|| String::from_str(&env, "Unknown"))
    }

    // Track energy generation (Proof-of-Generation)
    pub fn track_generation(env: Env, user: Address, token_contract : Address, energy_amount: i128) {
        assert!(energy_amount > 0, "Energy amount must be positive");
        let generation_key = symbol_short!("gen");
        let user_generation = env.storage().persistent().get(&(generation_key.clone(), &user)).unwrap_or(0);
        env.storage().persistent().set(&(generation_key.clone(), &user), &(user_generation + energy_amount));
        
        let token_client = gdxtoken::Client::new(&env, &token_contract);
        token_client.mint(&user, &energy_amount);
        // Emit an event for energy generation
        env.events().publish(
            ("gen", user.clone()),
            energy_amount,
        );
    }

    // Tokenize energy units as NFTs or fungible tokens
    pub fn tokenize_energy(env: Env, user: Address, admin : Address, token_contract : Address, energy_amount: i128, ) {

        // Ensure only the admin can tokenize energy
       assert!(env.storage().persistent().get(&admin).unwrap_or(false), "Unauthorized");
       assert!(energy_amount > 0, "Energy amount must be positive");
       let token_key = symbol_short!("etoken");
       let user_tokens = env.storage().persistent().get(&(token_key.clone(), &user)).unwrap_or(0);
       env.storage().persistent().set(&(token_key.clone(), &user), &(user_tokens + energy_amount));

       let token_client = gdxtoken::Client::new(&env, &admin);
       token_client.mint(&user, &energy_amount);

       // Emit an event for tokenization
       env.events().publish(
           ("tokenize", user.clone()),
           energy_amount,
       );

   }

    // Get total energy generated by user
    pub fn get_generation(env: Env, user: Address) -> i128 {
        let generation_key = symbol_short!("gen");
        env.storage().persistent().get(&(generation_key.clone(), &user)).unwrap_or(0)
    }

    // Get user energy balance
    pub fn get_energy_balance(env: Env, user: Address) -> i128 {
        let transfer_key = symbol_short!("transfer");
        env.storage().persistent().get(&(transfer_key.clone(), &user)).unwrap_or(0)
    }
    

    // Track energy transfer (Proof-of-Transfer)
    pub fn track_transfer(env: Env, from: Address, to: Address, energy_amount: i128, token_contract : Address) {
        assert!(energy_amount > 0, "Energy amount must be positive");

        let transfer_key = symbol_short!("transfer");
        let from_balance = env.storage().persistent().get(&(transfer_key.clone(), &from)).unwrap_or(0);
        assert!(from_balance >= energy_amount, "You do not have sufficient energy");

        env.storage().persistent().set(&(transfer_key.clone(), &from), &(from_balance - energy_amount));

        let to_balance = env.storage().persistent().get(&(transfer_key.clone(), &to)).unwrap_or(0);
        env.storage().persistent().set(&(transfer_key.clone(), &to), &(to_balance + energy_amount));
        

        let token_client = gdxtoken::Client::new(&env, &token_contract);
        token_client.transfer(&from, &to, &energy_amount);

        // Emit an event for energy transfer
        env.events().publish(
            ("transfer", from.clone(), to.clone()),
            energy_amount,
        );
    }

    // Track energy consumption (Proof-of-Consumption)
    pub fn track_consumption(env: Env, user: Address, energy_amount: i128) {
         assert!(energy_amount > 0, "Energy amount must be positive");

        let consumption_key = symbol_short!("consume");
        let user_consumption = env.storage()
            .persistent()
            .get(&(consumption_key.clone(), &user))
            .unwrap_or(0);
        env.storage()
            .persistent().set(&(consumption_key.clone(), &user), &(user_consumption + energy_amount));

        // Emit an event for energy consumption
        env.events().publish(
            ("consume", user.clone()),
            energy_amount,
        );
    }

    // Get user consumption data
    pub fn get_consumption(env: Env, user: Address) -> i128 {
        let consumption_key = symbol_short!("consume");
        env.storage().persistent().get(&(consumption_key.clone(), &user)).unwrap_or(0)
    }


    pub fn get_token_balance(env: Env, user: Address) -> i128 {
        let token_key = symbol_short!("etoken");
        env.storage().persistent().get(&(token_key.clone(), &user)).unwrap_or(0)
    }

    pub fn set_energy_price(env: Env, generator: Address, price_per_unit: i128) {
        assert!(price_per_unit > 0, "Price must be positive");
        let role: String = env.storage().persistent().get(&generator).unwrap_or_else(|| String::from_str(&env, "Unknown"));
        assert!(role == String::from_str(&env, "admin"), "Only Admins can set prices, which are made based on joint regulations scaling protocol ");
        env.storage().persistent().set(&(symbol_short!("price"), &generator), &price_per_unit);
    }

    // Get energy price
    pub fn get_energy_price(env: Env, generator: Address) -> i128 {
        env.storage().persistent().get(&(symbol_short!("price"), &generator)).unwrap_or(0)
    }

    // Buy energy from a Generator
    pub fn buy_energy(env: Env, consumer: Address, generator: Address, amount: i128, token_contract: Address) {
        let price_per_unit = env.storage().persistent().get(&(symbol_short!("price"), &generator)).unwrap_or(0);
        let total_cost = price_per_unit * amount;
        let consumer_tokens = env.storage().persistent().get(&(symbol_short!("etoken"), &consumer)).unwrap_or(0);
        let token_client = gdxtoken::Client::new(&env, &token_contract);
        let consumer_balance = token_client.balance(&consumer);
        assert!(consumer_balance >= total_cost, "Insufficient tokens");

        // Transfer tokens from consumer to generator
        token_client.transfer(&consumer, &generator, &total_cost);

        assert!(consumer_tokens >= total_cost, "Insufficient tokens");
        let generator_tokens = env.storage().persistent().get(&(symbol_short!("etoken"), &generator)).unwrap_or(0);
        env.storage().persistent().set(&(symbol_short!("etoken"), &consumer), &(consumer_tokens - total_cost));
        env.storage().persistent().set(&(symbol_short!("etoken"), &generator), &(generator_tokens + total_cost));
        Self::track_transfer(env.clone(), generator.clone(), consumer.clone(), amount, token_contract);
        env.events().publish(("buy", consumer.clone(), generator.clone()), amount);
    }

    pub fn sell_energy(env: Env, generator: Address, amount: i128, token_contract : Address) {
        assert!(amount > 0, "Amount must be positive");
    
        let price_per_unit = env.storage().persistent().get(&(symbol_short!("price"), &generator)).unwrap_or(0);
        assert!(price_per_unit > 0, "Price must be set before selling energy");
    
        let total_earnings = price_per_unit * amount;
        let generator_energy = env.storage().persistent().get(&(symbol_short!("gen"), &generator)).unwrap_or(0);
        assert!(generator_energy >= amount, "Insufficient energy balance");
    
        let generator_tokens = env.storage().persistent().get(&(symbol_short!("etoken"), &generator)).unwrap_or(0);
    
        // Deduct energy and add tokens
        env.storage().persistent().set(&(symbol_short!("gen"), &generator), &(generator_energy - amount));
        env.storage().persistent().set(&(symbol_short!("etoken"), &generator), &(generator_tokens + total_earnings));

        let token_client = gdxtoken::Client::new(&env, &token_contract);
       token_client.mint(&generator, &amount);
    
        // Publish sell event
        env.events().publish(("sell", generator.clone()), amount);
    }

    pub fn get_sold_energy(env: Env, generator: Address) -> i128 {
        let sold_key = symbol_short!("sold");
        env.storage().persistent().get(&(sold_key, &generator)).unwrap_or(0)
    }
    

}

mod test;
